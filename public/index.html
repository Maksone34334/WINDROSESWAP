<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MWS MONAD WINDROSE SWAP</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        /* Reset and base styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #0a0a0a;
            color: #ffffff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow-x: hidden;
        }
        
        /* Animation background */
        .animation-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            opacity: 0.4;
            pointer-events: none;
            overflow: hidden;
        }
        
        .particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background-color: #ffffff;
            border-radius: 50%;
            box-shadow: 0 0 10px 2px rgba(255, 255, 255, 0.8);
            animation: float 20s linear infinite;
        }
        
        .particle-large {
            width: 4px;
            height: 4px;
            box-shadow: 0 0 15px 5px rgba(255, 255, 255, 0.8);
        }
        
        .connection-line {
            position: absolute;
            background: linear-gradient(90deg, transparent, #ffffff, transparent);
            transform-origin: left center;
            opacity: 0.15;
            animation: pulse 3s ease-in-out infinite;
        }
        
        @keyframes float {
            0% {
                transform: translateY(0) translateX(0);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateY(-100vh) translateX(100px);
                opacity: 0;
            }
        }
        
        @keyframes pulse {
            0%, 100% {
                opacity: 0.05;
            }
            50% {
                opacity: 0.2;
            }
        }
        
        /* Animated gradient overlay */
        .gradient-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, rgba(10, 10, 10, 0) 0%, rgba(10, 10, 10, 0.8) 70%);
            z-index: 1;
            pointer-events: none;
            animation: gradientPulse 8s ease-in-out infinite;
        }
        
        @keyframes gradientPulse {
            0%, 100% {
                background: radial-gradient(circle at center, rgba(10, 10, 10, 0) 0%, rgba(10, 10, 10, 0.8) 70%);
            }
            50% {
                background: radial-gradient(circle at center, rgba(10, 10, 10, 0) 0%, rgba(10, 10, 10, 0.9) 60%);
            }
        }
        
        /* Header styles */
        header {
            background-color: rgba(15, 15, 15, 0.95);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
            z-index: 10;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.3);
        }
        
        .logo {
            color: #ffffff;
            font-weight: bold;
            font-size: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .logo-mws {
            width: 40px;
            height: 50px;
            background: #000;
            border: 2px solid #fff;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 900;
            font-size: 12px;
            line-height: 0.9;
            padding: 4px 2px;
            font-family: 'Arial Black', sans-serif;
        }
        
        .nav-links {
            display: flex;
            gap: 30px;
        }
        
        .nav-links a {
            color: #9e9e9e;
            text-decoration: none;
            font-size: 14px;
            position: relative;
            transition: color 0.3s ease;
        }
        
        .nav-links a.active {
            color: #ffffff;
        }
        
        .nav-links a::after {
            content: '';
            position: absolute;
            bottom: -5px;
            left: 0;
            width: 0;
            height: 2px;
            background-color: #ffffff;
            transition: width 0.3s ease;
        }
        
        .nav-links a:hover::after {
            width: 100%;
        }
        
        .nav-links a.active::after {
            width: 100%;
        }
        
        .header-buttons {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        .connect-wallet-btn {
            background-color: #000;
            color: #ffffff;
            border: 2px solid #fff;
            border-radius: 25px;
            padding: 10px 22px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            letter-spacing: 0.5px;
            transition: all 0.3s ease;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.2);
        }
        
        .connect-wallet-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.4);
            background-color: #222;
        }
        
        .connect-wallet-btn.connected {
            border-color: #00ff00;
            color: #00ff00;
        }
        
        .icon-button {
            background: none;
            border: none;
            color: #9e9e9e;
            cursor: pointer;
            font-size: 18px;
            transition: color 0.3s ease;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }
        
        .icon-button:hover {
            color: #ffffff;
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        /* Main content styles */
        main {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 40px 20px;
            position: relative;
            z-index: 5;
        }
        
        /* Swap card styles */
        .swap-card {
            background-color: rgba(20, 20, 20, 0.8);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 20px;
            width: 100%;
            max-width: 450px;
            padding: 30px;
            position: relative;
            z-index: 5;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .swap-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 60px rgba(0, 0, 0, 0.4);
        }
        
        .swap-nav {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
        }
        
        .swap-nav-item {
            background: none;
            border: none;
            color: #9e9e9e;
            cursor: pointer;
            font-size: 14px;
            padding: 8px 20px;
            border-radius: 15px;
            transition: all 0.3s ease;
        }
        
        .swap-nav-item.active {
            background-color: #000;
            color: #ffffff;
            font-weight: 600;
            border: 2px solid #fff;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.2);
        }
        
        .swap-nav-item:not(.active):hover {
            background-color: rgba(255, 255, 255, 0.1);
            color: #ffffff;
        }
        
        .swap-form {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .swap-section {
            background-color: rgba(30, 30, 30, 0.5);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            transition: border 0.3s ease;
        }
        
        .swap-section:hover {
            border: 1px solid rgba(255, 255, 255, 0.15);
        }
        
        .swap-label {
            color: #9e9e9e;
            font-size: 13px;
            margin-bottom: 15px;
            letter-spacing: 0.5px;
        }
        
        .swap-currency {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .currency-selector {
            display: flex;
            align-items: center;
            gap: 10px;
            background-color: rgba(40, 40, 40, 0.7);
            border-radius: 15px;
            padding: 8px 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.05);
            pointer-events: auto;
            position: relative;
            z-index: 1;
        }
        
        .currency-selector:hover {
            background-color: rgba(50, 50, 50, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.15);
        }
        
        .currency-icon {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background-color: #000;
            border: 1px solid #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #ffffff;
            font-weight: bold;
            overflow: hidden;
        }
        
        .currency-icon img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 50%;
        }
        
        .currency-icon.fallback {
            background-color: #000;
            border: 1px solid #fff;
        }
        
        .currency-code {
            font-weight: bold;
            font-size: 14px;
            color: #ffffff;
        }
        
        .dropdown-icon {
            color: #9e9e9e;
            font-size: 12px;
        }
        
        .amount-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }

        .amount-input-wrapper {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .swap-amount {
            font-size: 28px;
            font-weight: bold;
            text-align: center;
            transition: color 0.3s ease;
            color: #ffffff;
            background: none;
            border: none;
            outline: none;
            width: 160px;
        }
        
        .swap-amount::placeholder {
            color: rgba(255, 255, 255, 0.4);
        }
        
        .swap-balance {
            color: #9e9e9e;
            font-size: 12px;
            text-align: center;
            margin-top: 5px;
            font-weight: 500;
            width: 100%;
        }
        
        .max-btn {
            background: #000;
            color: white;
            border: 1px solid #fff;
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.3s;
            margin-left: 8px;
        }
        
        .max-btn:hover {
            background: #222;
        }
        
        .swap-button {
            display: flex;
            justify-content: center;
            margin-top: 5px;
            margin-bottom: 5px;
        }
        
        .convert-icon {
            background-color: rgba(20, 20, 20, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #ffffff;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            z-index: 6;
        }
        
        .convert-icon:hover {
            transform: rotate(180deg);
            background-color: #000;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        
        .swap-total {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            color: #9e9e9e;
            margin-top: 15px;
            padding: 10px 15px;
            border-radius: 10px;
            background-color: rgba(255, 255, 255, 0.05);
        }
        
        .swap-action {
            margin-top: 25px;
        }
        
        .main-swap-button {
            background-color: #000;
            color: #ffffff;
            border: 2px solid #fff;
            border-radius: 15px;
            padding: 15px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            letter-spacing: 0.5px;
            transition: all 0.3s ease;
            width: 100%;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.2);
            pointer-events: auto;
            position: relative;
            z-index: 1;
        }
        
        .main-swap-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.4);
            background-color: #222;
        }
        
        .main-swap-button:disabled {
            background-color: #333;
            cursor: not-allowed;
            box-shadow: none;
        }
        
        /* Hidden elements */
        .hidden {
            display: none;
        }
        
        /* Select styling */
        select {
            position: absolute;
            opacity: 0;
            pointer-events: none;
            background: #1a1a1a;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            outline: none;
            appearance: none;
            padding: 8px;
            font-size: 14px;
            width: 100%;
            max-height: 200px;
            overflow-y: auto;
        }
        
        select:focus {
            border-color: rgba(255, 255, 255, 0.5);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
        }
        
        select option {
            background: #1a1a1a;
            color: white;
            padding: 8px;
            border: none;
        }
        
        select option:hover {
            background: #333;
        }
        
        select option[style*="color: rgb(0, 255, 0)"] {
            background: rgba(0, 255, 0, 0.1);
            border-left: 3px solid #00ff00;
        }
        
        /* Token Selection Modal */
        .token-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }
        
        .token-modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        
        .token-modal {
            background: rgba(20, 20, 20, 0.95);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            width: 90%;
            max-width: 400px;
            max-height: 80vh;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            transform: scale(0.9) translateY(20px);
            transition: all 0.3s ease;
            overflow: hidden;
        }
        
        .token-modal-overlay.active .token-modal {
            transform: scale(1) translateY(0);
        }
        
        .token-modal-header {
            padding: 20px 25px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .token-modal-title {
            font-size: 18px;
            font-weight: 600;
            color: #ffffff;
            margin: 0;
        }
        
        .token-modal-close {
            background: none;
            border: none;
            color: #9e9e9e;
            font-size: 24px;
            cursor: pointer;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.3s ease;
        }
        
        .token-modal-close:hover {
            color: #ffffff;
            background: rgba(255, 255, 255, 0.1);
        }
        
        .token-search {
            padding: 20px 25px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .token-search-input {
            width: 100%;
            background: rgba(40, 40, 40, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 12px 16px;
            color: #ffffff;
            font-size: 14px;
            outline: none;
            transition: all 0.3s ease;
        }
        
        .token-search-input:focus {
            border-color: rgba(255, 255, 255, 0.3);
            background: rgba(50, 50, 50, 0.7);
        }
        
        .token-search-input::placeholder {
            color: rgba(255, 255, 255, 0.4);
        }
        
        .token-list {
            max-height: 400px;
            overflow-y: auto;
            padding: 10px 0;
        }
        
        .token-list::-webkit-scrollbar {
            width: 6px;
        }
        
        .token-list::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .token-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }
        
        .token-list::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .token-item {
            display: flex;
            align-items: center;
            padding: 12px 25px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
            background: none;
            width: 100%;
            text-align: left;
        }
        
        .token-item:hover {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .token-item.has-balance {
            background: rgba(0, 255, 0, 0.02);
            border-left: 3px solid rgba(0, 255, 0, 0.3);
        }
        
        .token-item.has-balance:hover {
            background: rgba(0, 255, 0, 0.05);
        }
        
        .token-logo {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            margin-right: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
            background: #000;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .token-logo img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 50%;
        }
        
        .token-logo.loading {
            background: linear-gradient(90deg, rgba(255,255,255,0.1) 25%, rgba(255,255,255,0.2) 50%, rgba(255,255,255,0.1) 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }
        
        @keyframes shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }
        
        .token-logo.fallback {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #ffffff;
            font-weight: bold;
            font-size: 14px;
        }
        
        .token-info {
            flex: 1;
            min-width: 0;
        }
        
        .token-symbol {
            font-size: 16px;
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 2px;
        }
        
        .token-name {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .token-balance {
            text-align: right;
            min-width: 80px;
        }
        
        .token-balance-amount {
            font-size: 14px;
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 2px;
        }
        
        .token-balance-amount.has-balance {
            color: #00ff00;
        }
        
        .token-balance-label {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.4);
        }
        
        .no-tokens-found {
            padding: 40px 25px;
            text-align: center;
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
        }
        
        /* Wallet Info */
        .wallet-info {
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid rgba(0, 255, 0, 0.3);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 20px;
            font-size: 14px;
        }
        
        /* Swap Info */
        .swap-info {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 16px;
            margin: 16px 0;
        }
        
        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 12px;
        }
        
        .info-row:last-child {
            margin-bottom: 0;
        }
        
        .info-label {
            color: rgba(255, 255, 255, 0.6);
        }
        
        .info-value {
            color: white;
            font-weight: 700;
        }
        
        /* Result */
        .result {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 16px;
            margin-top: 16px;
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
            max-height: 200px;
            overflow-y: auto;
            color: white;
        }
        
        /* Settings Panel */
        .settings-panel {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 20px;
        }
        
        .settings-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .settings-row:last-child {
            margin-bottom: 0;
        }
        
        .slippage-input {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 8px 12px;
            color: white;
            width: 80px;
            text-align: center;
            font-weight: 600;
        }
        
        .slippage-input:focus {
            outline: none;
            border-color: rgba(255, 255, 255, 0.5);
        }
        
        /* Background elements */
        .background-lines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 3;
            pointer-events: none;
        }
        
        .line {
            position: absolute;
            border: 1px solid rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(3px);
            -webkit-backdrop-filter: blur(3px);
        }
        
        .line-1 {
            width: 200px;
            height: 300px;
            border-radius: 20px;
            left: calc(50% - 300px);
            top: calc(50% - 150px);
            animation: floatLine 15s ease-in-out infinite;
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.1);
        }
        
        .line-2 {
            width: 200px;
            height: 300px;
            border-radius: 20px;
            right: calc(50% - 300px);
            top: calc(50% - 150px);
            animation: floatLine 15s ease-in-out infinite reverse;
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.1);
        }
        
        @keyframes floatLine {
            0%, 100% {
                transform: translateY(0) rotate(0deg);
            }
            50% {
                transform: translateY(-20px) rotate(2deg);
            }
        }
        
        /* Glow effects */
        .glow {
            position: absolute;
            background: radial-gradient(circle at center, rgba(255, 255, 255, 0.2) 0%, rgba(255, 255, 255, 0) 70%);
            border-radius: 50%;
            pointer-events: none;
        }
        
        .glow-1 {
            width: 300px;
            height: 300px;
            left: 20%;
            top: 20%;
            animation: pulseGlow 10s ease-in-out infinite;
        }
        
        .glow-2 {
            width: 400px;
            height: 400px;
            right: 10%;
            bottom: 10%;
            animation: pulseGlow 12s ease-in-out infinite 2s;
        }
        
        @keyframes pulseGlow {
            0%, 100% {
                opacity: 0.05;
                transform: scale(1);
            }
            50% {
                opacity: 0.1;
                transform: scale(1.2);
            }
        }
        
        /* Advanced glass reflection effect */
        .glass-reflection {
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, rgba(255, 255, 255, 0) 0%, rgba(255, 255, 255, 0.1) 50%, rgba(255, 255, 255, 0) 100%);
            transform: skewX(-20deg);
            animation: reflectionPass 8s ease-in-out;
            pointer-events: none;
            z-index: 2;
        }
        
        @keyframes reflectionPass {
            0% {
                left: -100%;
            }
            20%, 100% {
                left: 100%;
            }
        }
        
        .connect-button {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 14px;
            font-weight: 600;
            padding: 10px 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            pointer-events: auto;
            position: relative;
            z-index: 1;
        }
        
        .connect-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
        }
        
        .test-button {
            background: linear-gradient(135deg, #FF6B6B 0%, #ee5a52 100%);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 12px;
            font-weight: 600;
            padding: 8px 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-left: 10px;
            pointer-events: auto;
            position: relative;
            z-index: 1;
        }
        
        .test-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
        }
        
        /* Mobile Responsive */
        @media (max-width: 768px) {
            .nav-links {
                display: none;
            }
            
            .swap-card {
                margin: 0 10px;
                padding: 20px;
            }
            
            .line-1, .line-2 {
                display: none;
            }
            
            .token-modal {
                width: 95%;
                max-width: none;
                margin: 10px;
            }
            
            .token-modal-header,
            .token-search,
            .token-item {
                padding-left: 20px;
                padding-right: 20px;
            }
        }
    </style>
</head>
<body>
    <!-- Background animation -->
    <div class="animation-background" id="animationBackground"></div>
    <div class="gradient-overlay"></div>
    
    <div class="glow glow-1"></div>
    <div class="glow glow-2"></div>
    
    <header>
        <div class="logo">
            <div class="logo-mws">
                <div>M</div>
                <div>W</div>
                <div>S</div>
            </div>
            <span>Monad Windrose Swap</span>
        </div>
        <div class="nav-links">
            <a href="#">Dashboard</a>
            <a href="#" class="active">Swap</a>
            <a href="#">Liquidity <span style="font-size: 10px; opacity: 0.7;">(soon)</span></a>
            <a href="#">NFT <span style="font-size: 10px; opacity: 0.7;">(soon)</span></a>
            <a href="https://ossinthub.link" target="_blank" rel="noopener noreferrer">Osint Tools</a>
        </div>
        <div class="header-buttons">
            <button id="connect-wallet" class="connect-wallet-btn" onclick="connectWallet()">Connect Wallet</button>
        </div>
    </header>
    
    <main>
        <div class="background-lines">
            <div class="line line-1"></div>
            <div class="line line-2"></div>
        </div>
        
        <div class="swap-card">
            <div class="glass-reflection"></div>
            
            <!-- Wallet Info -->
            <div id="wallet-info" class="wallet-info hidden"></div>
            
            <div class="swap-nav">
                <button class="swap-nav-item active">Swap</button>
                <button class="swap-nav-item">Exchange</button>
                <button class="swap-nav-item" onclick="toggleSettings()">Settings</button>
            </div>
            
            <!-- Settings Panel -->
            <div id="settings-panel" class="settings-panel hidden">
                <div class="settings-row">
                    <span>Slippage Tolerance (%)</span>
                    <input type="number" id="slippage" class="slippage-input" value="1" step="0.1" min="0.1" max="50" onchange="updateQuote()">
                </div>
                <div class="settings-row">
                    <span>Transaction Deadline</span>
                    <span>20 minutes</span>
                </div>
            </div>
            
            <div class="swap-form">
                <div class="swap-section">
                    <div class="swap-label">You Pay</div>
                    <div class="swap-currency">
                        <div class="currency-selector" onclick="toggleTokenSelector('from')">
                            <div class="currency-icon" id="from-token-icon">M</div>
                            <div class="currency-code" id="from-token-symbol">MON</div>
                            <div class="dropdown-icon"><i class="fas fa-chevron-down"></i></div>
                            <select id="from-token" onchange="updateFromToken()">
                                <option value="">Select token...</option>
                            </select>
                        </div>
                        <div class="amount-container">
                            <div class="amount-input-wrapper">
                                <input type="number" id="from-amount" class="swap-amount" placeholder="0.00" step="0.01" min="0" oninput="updateQuote()">
                                <button class="max-btn" onclick="setMaxAmount()">MAX</button>
                            </div>
                            <div class="swap-balance" id="from-balance">Balance: 0.00</div>
                        </div>
                    </div>
                </div>
                
                <div class="swap-button">
                    <div class="convert-icon" onclick="reverseTokens()"><i class="fas fa-exchange-alt"></i></div>
                </div>
                
                <div class="swap-section">
                    <div class="swap-label">You Receive</div>
                    <div class="swap-currency">
                        <div class="currency-selector" onclick="toggleTokenSelector('to')">
                            <div class="currency-icon" id="to-token-icon">B</div>
                            <div class="currency-code" id="to-token-symbol">BEAN</div>
                            <div class="dropdown-icon"><i class="fas fa-chevron-down"></i></div>
                            <select id="to-token" onchange="updateToToken()">
                                <option value="">Select token...</option>
                            </select>
                        </div>
                        <div class="amount-container">
                            <div class="amount-input-wrapper">
                                <input type="number" id="to-amount" class="swap-amount" placeholder="0.00" readonly>
                            </div>
                            <div class="swap-balance" id="to-balance">Balance: 0.00</div>
                        </div>
                    </div>
                </div>
                
                <!-- Swap Info -->
                <div id="swap-info" class="swap-info hidden">
                    <div class="info-row">
                        <span class="info-label">Price Impact:</span>
                        <span class="info-value" id="price-impact">--</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Minimum Received:</span>
                        <span class="info-value" id="minimum-received">--</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Gas Estimate:</span>
                        <span class="info-value" id="gas-estimate">--</span>
                    </div>
                </div>
                
                <!-- Exchange Rate -->
                <div class="swap-total">
                    <span id="exchange-rate">1 MON = 0.00 BEAN</span>
                    <span><i class="fas fa-info-circle"></i></span>
                </div>
                
                <div class="swap-action">
                    <button id="swap-button" class="main-swap-button" onclick="executeSwap()" disabled>
                        Connect Wallet
                    </button>
                </div>
                
                <!-- Result -->
                <div id="result" class="result hidden"></div>
            </div>
        </div>
    </main>
    
    <!-- Token Selection Modal -->
    <div id="token-modal" class="token-modal-overlay">
        <div class="token-modal">
            <div class="token-modal-header">
                <h3 class="token-modal-title">Select Token</h3>
                <button class="token-modal-close" onclick="closeTokenModal()">×</button>
            </div>
            <div class="token-search">
                <input 
                    type="text" 
                    class="token-search-input" 
                    placeholder="Search tokens by name or symbol..."
                    id="token-search-input"
                    oninput="filterTokens()"
                >
            </div>
            <div class="token-list" id="token-list">
                <!-- Tokens will be populated here -->
            </div>
        </div>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <script>
        // Check if ethers.js loaded properly
        if (typeof ethers === 'undefined') {
            console.error('Ethers.js failed to load!');
            alert('Failed to load Ethers.js library. Please refresh the page.');
        }
        
        // Global variables
        let provider = null;
        let signer = null;
        let userAccount = null;
        let allTokens = [];
        let userBalances = {};
        let currentQuote = null;
        let currentModalType = null;
        let tokenLogos = {};
        let currentTokenType = null;
        let selectedFromToken = null;
        let selectedToToken = null;
        
        // UI Helper Functions
        function toggleSettings() {
            const panel = document.getElementById('settings-panel');
            panel.classList.toggle('hidden');
        }

        function toggleTokenSelector(type) {
            currentTokenType = type;
            const modal = document.getElementById('token-modal');
            const title = document.querySelector('.token-modal-title');
            
            title.textContent = type === 'from' ? 'Select Token to Swap From' : 'Select Token to Swap To';
            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
            
            const searchInput = document.getElementById('token-search-input');
            if (searchInput) {
                searchInput.focus();
            }
            
            // Загружаем токены при открытии модального окна
            loadTokensForModal();
        }

        // Функция для загрузки токенов в модальное окно
        async function loadTokensForModal() {
            try {
                console.log('Загружаем токены для модального окна...');
                
                // Показываем индикатор загрузки
                const tokenList = document.getElementById('token-list');
                tokenList.innerHTML = '<div style="text-align: center; padding: 20px; color: #888;">Загрузка токенов...</div>';
                
                // Загружаем верифицированные токены
                const response = await fetch('/api/tokens/category/verified?limit=50');
                const data = await response.json();
                
                if (data.success && data.data) {
                    console.log('Токены загружены:', data.data.length);
                    allTokens = data.data;
                    populateTokenModal(allTokens);
                } else {
                    throw new Error('Не удалось загрузить токены');
                }
            } catch (error) {
                console.error('Ошибка загрузки токенов:', error);
                const tokenList = document.getElementById('token-list');
                tokenList.innerHTML = '<div style="text-align: center; padding: 20px; color: #ff6b6b;">Ошибка загрузки токенов</div>';
            }
        }

        function closeTokenModal() {
            const modal = document.getElementById('token-modal');
            modal.classList.remove('active');
            document.body.style.overflow = 'auto';
        }

        // Обновленная функция для заполнения модального окна токенами
        function populateTokenModal(tokens = []) {
            const tokenList = document.getElementById('token-list');
            
            if (!tokens || tokens.length === 0) {
                tokenList.innerHTML = '<div style="text-align: center; padding: 20px; color: #888;">Токены не найдены</div>';
                return;
            }
            
            tokenList.innerHTML = '';
            
            tokens.forEach(token => {
                const tokenItem = document.createElement('div');
                tokenItem.className = 'token-item';
                tokenItem.style.cssText = `
                    display: flex;
                    align-items: center;
                    padding: 12px 16px;
                    cursor: pointer;
                    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
                    transition: background-color 0.2s ease;
                `;
                
                // Определяем баланс токена
                const balance = userBalances[token.address] || '0';
                const hasBalance = parseFloat(balance) > 0;
                
                if (hasBalance) {
                    tokenItem.style.backgroundColor = 'rgba(34, 197, 94, 0.1)';
                }
                
                tokenItem.innerHTML = `
                    <div style="width: 32px; height: 32px; margin-right: 12px; border-radius: 50%; overflow: hidden; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); display: flex; align-items: center; justify-content: center;">
                        <img src="https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/${token.address}/logo.png" 
                             alt="${token.symbol}" 
                             style="width: 100%; height: 100%; object-fit: cover;"
                             onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                        <div style="display: none; color: white; font-weight: bold; font-size: 12px;">${token.symbol.charAt(0)}</div>
                    </div>
                    <div style="flex: 1;">
                        <div style="font-weight: 600; color: white; margin-bottom: 2px;">${token.symbol}</div>
                        <div style="font-size: 12px; color: #888; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${token.name}</div>
                    </div>
                    ${hasBalance ? `<div style="color: #22c55e; font-size: 12px; font-weight: 500;">${parseFloat(balance).toFixed(4)}</div>` : ''}
                `;
                
                tokenItem.addEventListener('mouseenter', () => {
                    if (!hasBalance) {
                        tokenItem.style.backgroundColor = 'rgba(255, 255, 255, 0.05)';
                    }
                });
                
                tokenItem.addEventListener('mouseleave', () => {
                    if (!hasBalance) {
                        tokenItem.style.backgroundColor = 'transparent';
                    }
                });
                
                tokenItem.addEventListener('click', () => selectToken(token));
                
                tokenList.appendChild(tokenItem);
            });
        }

        // Функция выбора токена
        function selectToken(token) {
            console.log('Выбран токен:', token);
            
            if (currentTokenType === 'from') {
                selectedFromToken = token;
                document.getElementById('from-token-symbol').textContent = token.symbol;
                document.getElementById('from-token').value = token.symbol;
                updateTokenDisplay('from', token.symbol);
            } else {
                selectedToToken = token;
                document.getElementById('to-token-symbol').textContent = token.symbol;
                document.getElementById('to-token').value = token.symbol;
                updateTokenDisplay('to', token.symbol);
            }
            
            closeTokenModal();
            updateBalanceDisplays();
            updateQuote();
        }

        // Функция поиска токенов
        function searchTokens() {
            const searchTerm = document.getElementById('token-search-input').value.toLowerCase();
            
            if (!allTokens) return;
            
            const filteredTokens = allTokens.filter(token => 
                token.symbol.toLowerCase().includes(searchTerm) || 
                token.name.toLowerCase().includes(searchTerm)
            );
            
            populateTokenModal(filteredTokens);
        }
        // Fallback token list if API fails
        const FALLBACK_TOKENS = [
            {symbol: "MON", name: "Monad", address: "0x0000000000000000000000000000000000000000"},
            {symbol: "WMON", name: "Wrapped Monad", address: "0x760afe86e5de5fa0ee542fc7b7b713e1c5425701"},
            {symbol: "BEAN", name: "Bean Exchange", address: "0x268e4e24e0051ec27b3d27a95977e71ce6875a05"},
            {symbol: "CHOG", name: "Chog", address: "0xe0590015a873bf326bd645c3e1266d4db41c4e6b"},
            {symbol: "ATL", name: "Atlantis", address: "0x1ea9099e3026e0b3f8dd6fbacaa45f30fce67431"},
            {symbol: "DAK", name: "Molandak", address: "0x0f0bdebf0f83cd1ee3974779bcb7315f9808c714"},
            {symbol: "HALLI", name: "Halliday", address: "0x6ce1890eeadae7db01026f4b294cb8ec5ecc6563"},
            {symbol: "gMON", name: "gMON", address: "0xaeef2f6b429cb59c9b2d7bb2141ada993e8571c3"},
            {symbol: "aprMON", name: "aPriori Monad LST", address: "0xb2f82d0f38dc453d596ad40a37799446cc89274a"},
            {symbol: "BMONAD", name: "buja Monad", address: "0x3552f8254263ea8880c7f7e25cb8dbbd79c0c4b1"},
        ];

        // Monad network configuration
        const MONAD_NETWORK = {
            chainId: '0x279F', // 10143 in hex
            chainName: 'Monad Testnet',
            nativeCurrency: {
                name: 'MON',
                symbol: 'MON',
                decimals: 18
            },
            rpcUrls: ['https://testnet-rpc.monad.xyz'],
            blockExplorerUrls: ['https://testnet-explorer.monad.xyz']
        };

        // Token colors for generated icons
        const TOKEN_COLORS = {
            'MON': '#4A90E2',
            'WMON': '#5C9BD1', 
            'BEAN': '#2ECC71',
            'CHOG': '#E74C3C',
            'ATL': '#9B59B6',
            'DAK': '#F39C12',
            'HALLI': '#1ABC9C',
            'gMON': '#34495E',
            'aprMON': '#E67E22',
            'BMONAD': '#16A085'
        };

        // Token logo sources - multiple APIs for better coverage
        const LOGO_APIS = [
            {
                name: 'CoinGecko',
                getUrl: (symbol, address) => `https://api.coingecko.com/api/v3/coins/ethereum/contract/${address.toLowerCase()}`,
                extractLogo: (data) => data?.image?.large || data?.image?.small || data?.image?.thumb
            },
            {
                name: 'TokenLists',
                getUrl: (symbol, address) => `https://tokens.coingecko.com/uniswap/all.json`,
                extractLogo: (data, address) => {
                    const token = data?.tokens?.find(t => t.address?.toLowerCase() === address.toLowerCase());
                    return token?.logoURI;
                }
            },
            {
                name: 'TrustWallet',
                getUrl: (symbol, address) => `https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/${address}/logo.png`,
                extractLogo: () => null // Direct URL, no extraction needed
            }
        ];

        // Enhanced token logo fetching with multiple fallbacks
        async function fetchTokenLogo(symbol, address) {
            // Check cache first
            const cacheKey = `${symbol}-${address}`;
            if (tokenLogos[cacheKey]) {
                return tokenLogos[cacheKey];
            }

            // Skip logo fetching for native token
            if (address === '0x0000000000000000000000000000000000000000') {
                const fallbackLogo = generateTokenIcon(symbol);
                tokenLogos[cacheKey] = fallbackLogo;
                return fallbackLogo;
            }

            // Try TrustWallet first (direct image URL)
            try {
                const trustWalletUrl = `https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/${address}/logo.png`;
                const response = await fetch(trustWalletUrl, { method: 'HEAD' });
                if (response.ok) {
                    tokenLogos[cacheKey] = trustWalletUrl;
                    return trustWalletUrl;
                }
            } catch (error) {
                console.log(`TrustWallet logo not found for ${symbol}`);
            }

            // Try alternative logo sources
            const alternativeLogos = {
                'WETH': 'https://assets.coingecko.com/coins/images/2518/large/weth.png',
                'USDC': 'https://assets.coingecko.com/coins/images/6319/large/USD_Coin_icon.png',
                'USDT': 'https://assets.coingecko.com/coins/images/325/large/Tether.png',
                'DAI': 'https://assets.coingecko.com/coins/images/9956/large/4943.png',
                'WBTC': 'https://assets.coingecko.com/coins/images/7598/large/wrapped_bitcoin_wbtc.png',
                'UNI': 'https://assets.coingecko.com/coins/images/12504/large/uniswap-uni.png',
                'LINK': 'https://assets.coingecko.com/coins/images/877/large/chainlink-new-logo.png',
                'AAVE': 'https://assets.coingecko.com/coins/images/12645/large/AAVE.png'
            };

            if (alternativeLogos[symbol.toUpperCase()]) {
                tokenLogos[cacheKey] = alternativeLogos[symbol.toUpperCase()];
                return alternativeLogos[symbol.toUpperCase()];
            }

            // Fallback to generated icon
            const fallbackLogo = generateTokenIcon(symbol);
            tokenLogos[cacheKey] = fallbackLogo;
            return fallbackLogo;
        }

        // Token Modal Functions
        function openTokenModal(type) {
            currentModalType = type;
            const modal = document.getElementById('token-modal');
            const title = document.querySelector('.token-modal-title');
            
            title.textContent = `Select ${type === 'from' ? 'Source' : 'Destination'} Token`;
            
            populateTokenModal();
            modal.classList.add('active');
            
            // Focus search input
            setTimeout(() => {
                document.getElementById('token-search-input').focus();
            }, 300);
        }

        function closeTokenModal() {
            const modal = document.getElementById('token-modal');
            modal.classList.remove('active');
            
            // Clear search
            document.getElementById('token-search-input').value = '';
            currentModalType = null;
        }

        function selectToken(symbol) {
            if (!currentModalType) return;
            
            const select = document.getElementById(currentModalType + '-token');
            select.value = symbol;
            
            if (currentModalType === 'from') {
                updateFromToken();
            } else {
                updateToToken();
            }
            
            closeTokenModal();
        }

        async function populateTokenModal() {
            const tokenList = document.getElementById('token-list');
            tokenList.innerHTML = '<div class="no-tokens-found">Loading tokens...</div>';
            
            if (!Array.isArray(allTokens) || allTokens.length === 0) {
                tokenList.innerHTML = '<div class="no-tokens-found">No tokens available</div>';
                return;
            }
            
            // Sort tokens: tokens with balance first, then alphabetically
            const sortedTokens = [...allTokens].sort((a, b) => {
                const balanceA = parseFloat(userBalances[a.symbol] || a.balance || '0');
                const balanceB = parseFloat(userBalances[b.symbol] || b.balance || '0');
                
                if (balanceA > 0 && balanceB === 0) return -1;
                if (balanceA === 0 && balanceB > 0) return 1;
                
                return a.symbol.localeCompare(b.symbol);
            });
            
            tokenList.innerHTML = '';
            
            for (const token of sortedTokens) {
                const tokenItem = await createTokenItem(token);
                tokenList.appendChild(tokenItem);
            }
        }

        async function createTokenItem(token) {
            const balance = userBalances[token.symbol] || token.balance || '0';
            const balanceFloat = parseFloat(balance);
            const hasBalance = balanceFloat > 0;
            
            const balanceDisplay = hasBalance ? 
                (balanceFloat < 0.01 ? '< 0.01' : balanceFloat.toFixed(4)) : '0.00';
            
            const item = document.createElement('button');
            item.className = `token-item ${hasBalance ? 'has-balance' : ''}`;
            item.onclick = () => selectToken(token.symbol);
            
            // Create logo element
            const logoDiv = document.createElement('div');
            logoDiv.className = 'token-logo loading';
            
            // Create token info
            const infoDiv = document.createElement('div');
            infoDiv.className = 'token-info';
            infoDiv.innerHTML = `
                <div class="token-symbol">${token.symbol}</div>
                <div class="token-name">${token.name}</div>
            `;
            
            // Create balance info
            const balanceDiv = document.createElement('div');
            balanceDiv.className = 'token-balance';
            balanceDiv.innerHTML = `
                <div class="token-balance-amount ${hasBalance ? 'has-balance' : ''}">${balanceDisplay}</div>
                <div class="token-balance-label">Balance</div>
            `;
            
            item.appendChild(logoDiv);
            item.appendChild(infoDiv);
            item.appendChild(balanceDiv);
            
            // Load logo asynchronously
            fetchTokenLogo(token.symbol, token.address).then(logoUrl => {
                logoDiv.classList.remove('loading');
                
                if (logoUrl && logoUrl.startsWith('http')) {
                    const img = document.createElement('img');
                    img.src = logoUrl;
                    img.alt = token.symbol;
                    img.onerror = () => {
                        // Fallback to generated icon on error
                        logoDiv.classList.add('fallback');
                        logoDiv.innerHTML = token.symbol.charAt(0).toUpperCase();
                    };
                    logoDiv.appendChild(img);
                } else {
                    // Use generated SVG icon
                    const img = document.createElement('img');
                    img.src = logoUrl;
                    img.alt = token.symbol;
                    logoDiv.appendChild(img);
                }
            }).catch(() => {
                logoDiv.classList.remove('loading');
                logoDiv.classList.add('fallback');
                logoDiv.innerHTML = token.symbol.charAt(0).toUpperCase();
            });
            
            return item;
        }

        function filterTokens() {
            const searchTerm = document.getElementById('token-search-input').value.toLowerCase();
            const tokenItems = document.querySelectorAll('.token-item');
            
            let visibleCount = 0;
            tokenItems.forEach(item => {
                const symbol = item.querySelector('.token-symbol').textContent.toLowerCase();
                const name = item.querySelector('.token-name').textContent.toLowerCase();
                
                if (symbol.includes(searchTerm) || name.includes(searchTerm)) {
                    item.style.display = 'flex';
                    visibleCount++;
                } else {
                    item.style.display = 'none';
                }
            });
            
            // Show "no results" message if no tokens match
            const tokenList = document.getElementById('token-list');
            let noResultsMsg = tokenList.querySelector('.no-tokens-found');
            
            if (visibleCount === 0 && searchTerm) {
                if (!noResultsMsg) {
                    noResultsMsg = document.createElement('div');
                    noResultsMsg.className = 'no-tokens-found';
                    tokenList.appendChild(noResultsMsg);
                }
                noResultsMsg.textContent = 'No tokens found matching your search';
                noResultsMsg.style.display = 'block';
            } else if (noResultsMsg) {
                noResultsMsg.style.display = 'none';
            }
        }

        // Generate SVG icon for token
        function generateTokenIcon(symbol) {
            const color = TOKEN_COLORS[symbol] || '#6C7B7F';
            const letter = symbol.charAt(0).toUpperCase();
            
            return `data:image/svg+xml;base64,${btoa(`
                <svg width="25" height="25" viewBox="0 0 25 25" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="12.5" cy="12.5" r="12.5" fill="${color}"/>
                    <text x="12.5" y="16" font-family="Arial, sans-serif" font-size="12" font-weight="bold" fill="white" text-anchor="middle">${letter}</text>
                </svg>
            `)}`;
        }

        // Function to get token logo URL  
        function getTokenLogoUrl(symbol, address, tokenData = null) {
            // Always return generated SVG icon for reliability
            // This is now enhanced by the fetchTokenLogo function for the modal
            return generateTokenIcon(symbol);
        }

        // Updated function to display token with logo
        function updateTokenDisplay(type, symbol) {
            const iconEl = document.getElementById(type + '-token-icon');
            const symbolEl = document.getElementById(type + '-token-symbol');
            
            if (symbol && iconEl && symbolEl) {
                symbolEl.textContent = symbol;
                
                // Clear previous content
                iconEl.innerHTML = '';
                iconEl.classList.remove('fallback');
                
                // Generate and set SVG icon
                const logoUrl = generateTokenIcon(symbol);
                const img = document.createElement('img');
                
                img.src = logoUrl;
                img.alt = symbol;
                img.style.width = '100%';
                img.style.height = '100%';
                img.style.borderRadius = '50%';
                
                iconEl.appendChild(img);
            }
        }

        // Add Monad network to wallet
        async function addMonadNetwork() {
            try {
                await window.ethereum.request({
                    method: 'wallet_addEthereumChain',
                    params: [MONAD_NETWORK]
                });
                showResult('✅ Monad Testnet added to wallet successfully!');
            } catch (error) {
                console.error('Add network error:', error);
                if (error.code === 4001) {
                    showResult('❌ User rejected network addition');
                } else {
                    showResult(`❌ Failed to add Monad network: ${error.message}`);
                }
            }
        }

        // Wallet connection functionality
        async function connectWallet() {
            try {
                if (typeof window.ethereum === 'undefined') {
                    alert('MetaMask is not installed. Please install MetaMask to continue.');
                    return;
                }

                // Request account access
                const accounts = await window.ethereum.request({
                    method: 'eth_requestAccounts'
                });

                if (accounts.length === 0) {
                    alert('No accounts found. Please unlock MetaMask.');
                    return;
                }

                currentAccount = accounts[0];
                
                // Update UI
                document.getElementById('connectWalletBtn').textContent = 
                    `Connected: ${currentAccount.slice(0, 6)}...${currentAccount.slice(-4)}`;
                document.getElementById('connectWalletBtn').disabled = true;
                
                // Show wallet-dependent buttons
                document.getElementById('myBalanceBtn').style.display = 'inline-block';
                document.getElementById('executeSwapBtn').style.display = 'inline-block';

                console.log('Wallet connected:', currentAccount);
                
                // Try to switch to Monad network
                await addMonadNetwork();
                
            } catch (error) {
                console.error('Error connecting wallet:', error);
                alert('Failed to connect wallet: ' + error.message);
            }
        }

        // Check wallet connection status
        async function checkWalletConnection() {
            if (typeof window.ethereum !== 'undefined') {
                try {
                    const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                    if (accounts.length > 0) {
                        currentAccount = accounts[0];
                        updateWalletUI();
                        return true;
                    }
                } catch (error) {
                    console.error('Error checking wallet connection:', error);
                }
            }
            return false;
        }

        // Update wallet UI
        function updateWalletUI() {
            const connectBtn = document.getElementById('connect-wallet');
            const walletInfo = document.getElementById('wallet-info');
            const swapButton = document.getElementById('swap-button');

            if (userAccount) {
                connectBtn.textContent = `${userAccount.slice(0, 6)}...${userAccount.slice(-4)}`;
                connectBtn.classList.add('connected');
                
                walletInfo.classList.remove('hidden');
                walletInfo.innerHTML = `
                    <strong>Connected:</strong> ${userAccount.slice(0, 6)}...${userAccount.slice(-4)}<br>
                    <strong>Network:</strong> Monad Testnet
                `;
                
                if (swapButton) {
                    swapButton.disabled = false;
                    swapButton.textContent = 'Get Quote';
                }
                
                await loadTokens();
                await loadUserBalances();
            } else {
                connectBtn.textContent = 'Connect Wallet';
                connectBtn.classList.remove('connected');
                
                walletInfo.classList.add('hidden');
                
                if (swapButton) {
                    swapButton.disabled = true;
                    swapButton.textContent = 'Connect Wallet';
                }
            }
        }

        // Wallet connection functionality
        async function connectWallet() {
            console.log('Connect wallet function called');
            
            if (typeof window.ethereum === 'undefined') {
                showResult('❌ Wallet not detected. Please install a Web3 wallet extension.');
                return false;
            }

            try {
                showResult('🔄 Connecting to wallet...');
                
                // Request account access
                const accounts = await window.ethereum.request({
                    method: 'eth_requestAccounts'
                });
                
                if (!accounts || accounts.length === 0) {
                    showResult('❌ No accounts found. Please unlock your wallet and try again.');
                    return false;
                }

                console.log('Accounts found:', accounts);
                userAccount = accounts[0];

                // Initialize provider and signer
                provider = new ethers.providers.Web3Provider(window.ethereum);
                
                // Wait for provider to be ready
                await provider.ready;
                
                signer = provider.getSigner();
                
                // Verify signer
                try {
                    const signerAddress = await signer.getAddress();
                    console.log('Signer address:', signerAddress);
                    if (signerAddress.toLowerCase() !== userAccount.toLowerCase()) {
                        throw new Error('Signer address mismatch');
                    }
                } catch (signerError) {
                    console.error('Signer verification failed:', signerError);
                    // Try to reinitialize
                    provider = new ethers.providers.Web3Provider(window.ethereum);
                    signer = provider.getSigner();
                }
                
                const network = await provider.getNetwork();
                console.log('Current network:', network);
                
                // Monad testnet chain ID is 10143 (0x279F)
                if (network.chainId !== 10143) {
                    showResult('⚠️ Wrong network detected. Will continue but recommend switching to Monad...');
                    
                    try {
                        await window.ethereum.request({
                            method: 'wallet_switchEthereumChain',
                            params: [{ chainId: '0x279F' }]
                        });
                        
                        await new Promise(resolve => setTimeout(resolve, 1000));
                        provider = new ethers.providers.Web3Provider(window.ethereum);
                        signer = provider.getSigner();
                        
                    } catch (switchError) {
                        console.log('Switch error:', switchError);
                        if (switchError.code === 4902) {
                            try {
                                await addMonadNetwork();
                                await new Promise(resolve => setTimeout(resolve, 2000));
                                provider = new ethers.providers.Web3Provider(window.ethereum);
                                signer = provider.getSigner();
                            } catch (addError) {
                                console.log('Failed to add network, continuing with current network');
                            }
                        }
                    }
                }
                
                if (!signer) {
                    provider = new ethers.providers.Web3Provider(window.ethereum);
                    signer = provider.getSigner();
                }
                
                try {
                    const signerAddress = await signer.getAddress();
                    console.log('Signer verified:', signerAddress);
                } catch (signerError) {
                    console.error('Signer error:', signerError);
                    throw new Error('Failed to create signer');
                }
                
                console.log('Wallet connected:', userAccount);
                await updateWalletUI();
                showResult(`✅ Wallet connected successfully!\nAddress: ${userAccount}\nNetwork: ${network.name || 'Unknown'}`);
                return true;
                
            } catch (error) {
                console.error('Wallet connection error:', error);
                let errorMessage = 'Unknown error';
                
                if (error.code === 4001) {
                    errorMessage = 'Connection rejected by user';
                } else if (error.code === -32002) {
                    errorMessage = 'Connection request already pending. Please check your wallet.';
                } else if (error.code === -32603) {
                    errorMessage = 'Internal error. Please try refreshing the page.';
                } else if (error.message) {
                    errorMessage = error.message;
                }
                
                showResult(`❌ Failed to connect wallet: ${errorMessage}`);
                return false;
            }
        }

        async function updateWalletUI() {
            const connectBtn = document.getElementById('connect-wallet');
            const walletInfo = document.getElementById('wallet-info');
            const swapButton = document.getElementById('swap-button');

            if (userAccount) {
                connectBtn.textContent = `${userAccount.slice(0, 6)}...${userAccount.slice(-4)}`;
                connectBtn.classList.add('connected');
                
                walletInfo.classList.remove('hidden');
                walletInfo.innerHTML = `
                    <strong>Connected:</strong> ${userAccount.slice(0, 6)}...${userAccount.slice(-4)}<br>
                    <strong>Network:</strong> Monad Testnet
                `;
                
                if (swapButton) {
                    swapButton.disabled = false;
                    swapButton.textContent = 'Get Quote';
                }
                
                await loadTokens();
                await loadUserBalances();
            } else {
                connectBtn.textContent = 'Connect Wallet';
                connectBtn.classList.remove('connected');
                
                walletInfo.classList.add('hidden');
                
                if (swapButton) {
                    swapButton.disabled = true;
                    swapButton.textContent = 'Connect Wallet';
                }
            }
        }

        // Load all available tokens
        async function loadTokens() {
            try {
                showResult('🔄 Loading available tokens...');
                // Load verified tokens which has much more tokens (47 vs 10)
                const response = await fetch('/api/tokens/category/verified');
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                if (data.success && Array.isArray(data.data)) {
                    allTokens = data.data;
                    console.log(`Loaded ${allTokens.length} verified tokens:`, allTokens.slice(0, 5));
                    populateTokenSelectors();
                    showResult(`✅ Loaded ${allTokens.length} verified tokens successfully`);
                    return true;
                } else {
                    throw new Error(data.error || 'Invalid response format');
                }
            } catch (error) {
                console.error('Failed to load tokens:', error);
                showResult(`❌ Failed to load tokens: ${error.message}`);
                
                allTokens = FALLBACK_TOKENS;
                populateTokenSelectors();
                showResult('⚠️ Using fallback token list. Some tokens may not be available.');
                return false;
            }
        }

        function populateTokenSelectors() {
            const fromSelect = document.getElementById('from-token');
            const toSelect = document.getElementById('to-token');
            
            if (!fromSelect || !toSelect) {
                console.error('Token selector elements not found');
                return;
            }
            
            fromSelect.innerHTML = '<option value="">Select token...</option>';
            toSelect.innerHTML = '<option value="">Select token...</option>';
            
            if (!Array.isArray(allTokens) || allTokens.length === 0) {
                console.warn('No tokens available to populate selectors');
                return;
            }
            
            console.log('Populating selectors with', allTokens.length, 'tokens');
            
            const sortedTokens = [...allTokens].sort((a, b) => a.symbol.localeCompare(b.symbol));
            
            sortedTokens.forEach(token => {
                if (token.symbol && token.name) {
                    // Get balance for this token
                    const balance = userBalances[token.symbol] || token.balance || '0.00';
                    const balanceFloat = parseFloat(balance);
                    const balanceDisplay = balanceFloat > 0 ? 
                        (balanceFloat < 0.01 ? '< 0.01' : balanceFloat.toFixed(4)) : '0.00';
                    
                    // Create option text with balance
                    const optionText = `${token.symbol} - ${token.name} (${balanceDisplay})`;
                    
                    const option1 = new Option(optionText, token.symbol);
                    const option2 = new Option(optionText, token.symbol);
                    
                    // Add special styling for tokens with balance
                    if (balanceFloat > 0) {
                        option1.style.fontWeight = 'bold';
                        option1.style.color = '#00ff00';
                        option2.style.fontWeight = 'bold';
                        option2.style.color = '#00ff00';
                    }
                    
                    fromSelect.appendChild(option1);
                    toSelect.appendChild(option2);
                }
            });
            
            const hasToken = (symbol) => sortedTokens.some(t => t.symbol === symbol);
            
            if (hasToken('MON')) {
                fromSelect.value = 'MON';
                updateTokenDisplay('from', 'MON');
            }
            if (hasToken('BEAN')) {
                toSelect.value = 'BEAN';
                updateTokenDisplay('to', 'BEAN');
            }
            
            console.log('Token selectors populated, from:', fromSelect.value, 'to:', toSelect.value);
            
            updateFromToken();
            updateToToken();
        }

        async function loadUserBalances() {
            if (!userAccount) {
                console.log('No user account, skipping balance loading');
                return;
            }
            
            try {
                showResult('🔄 Loading wallet balances...');
                
                // First try to get balances from API
                const response = await fetch(`/api/wallet/${userAccount}/balances`);
                
                if (response.ok) {
                    const data = await response.json();
                    
                    if (data.success && Array.isArray(data.data)) {
                        userBalances = {};
                        data.data.forEach(balance => {
                            if (balance.symbol && balance.balance !== undefined) {
                                userBalances[balance.symbol] = parseFloat(balance.balance).toFixed(6);
                            }
                        });
                        
                        console.log('Loaded balances from API:', userBalances);
                        updateBalanceDisplays();
                        populateTokenSelectors(); // Refresh token selectors with new balances
                        showResult(`✅ Loaded balances for ${data.data.length} tokens`);
                        return;
                    }
                }
                
                // Fallback: extract balances from token data that already has balance field
                console.log('Using balances from token data');
                userBalances = {};
                allTokens.forEach(token => {
                    if (token.symbol && token.balance !== undefined) {
                        const balance = parseFloat(token.balance);
                        if (balance > 0) {
                            userBalances[token.symbol] = balance.toFixed(6);
                        }
                    }
                });
                
                console.log('Extracted balances from tokens:', userBalances);
                updateBalanceDisplays();
                populateTokenSelectors(); // Refresh token selectors with new balances
                showResult(`✅ Loaded balances from token data`);
                
            } catch (error) {
                console.error('Failed to load balances:', error);
                showResult(`❌ Failed to load balances: ${error.message}`);
                userBalances = {};
                updateBalanceDisplays();
            }
        }

        function updateBalanceDisplays() {
            const fromToken = document.getElementById('from-token').value;
            const toToken = document.getElementById('to-token').value;
            
            const fromBalance = userBalances[fromToken] || '0.00';
            const toBalance = userBalances[toToken] || '0.00';
            
            document.getElementById('from-balance').textContent = `Balance: ${fromBalance}`;
            document.getElementById('to-balance').textContent = `Balance: ${toBalance}`;
        }

        function updateFromToken() {
            const fromToken = document.getElementById('from-token').value;
            updateTokenDisplay('from', fromToken);
            updateBalanceDisplays();
            updateQuote();
        }

        function updateToToken() {
            const toToken = document.getElementById('to-token').value;
            updateTokenDisplay('to', toToken);
            updateBalanceDisplays();
            updateQuote();
        }

        function setMaxAmount() {
            const fromToken = document.getElementById('from-token').value;
            const balance = userBalances[fromToken] || '0';
            
            document.getElementById('from-amount').value = balance;
            updateQuote();
        }

        function reverseTokens() {
            const fromSelect = document.getElementById('from-token');
            const toSelect = document.getElementById('to-token');
            
            const fromValue = fromSelect.value;
            const toValue = toSelect.value;
            
            fromSelect.value = toValue;
            toSelect.value = fromValue;
            
            updateFromToken();
            updateToToken();
        }

        function showResult(text) {
            const resultDiv = document.getElementById('result');
            resultDiv.classList.remove('hidden');
            resultDiv.textContent = text;
        }

        let quoteTimeout;
        async function updateQuote() {
            clearTimeout(quoteTimeout);
            
            const fromToken = document.getElementById('from-token').value;
            const toToken = document.getElementById('to-token').value;
            const amount = document.getElementById('from-amount').value;
            
            if (!fromToken || !toToken || !amount || amount <= 0 || fromToken === toToken) {
                document.getElementById('to-amount').value = '';
                document.getElementById('swap-info').classList.add('hidden');
                currentQuote = null;
                updateSwapButton();
                return;
            }
            
            quoteTimeout = setTimeout(async () => {
                await getQuote();
            }, 500);
        }

        async function getQuote() {
            const fromToken = document.getElementById('from-token').value;
            const toToken = document.getElementById('to-token').value;
            const amount = document.getElementById('from-amount').value;
            const slippage = document.getElementById('slippage').value;

            if (!amount || amount <= 0) {
                return;
            }

            if (fromToken === toToken) {
                showResult('❌ Please select different tokens');
                return;
            }

            try {
                console.log('Getting quote:', { fromToken, toToken, amount, slippage });
                
                const requestBody = {
                    amount: amount.toString(),
                    from: fromToken,
                    to: toToken,
                    slippage: parseFloat(slippage) * 100
                };
                
                if (userAccount) {
                    requestBody.sender = userAccount;
                }

                const response = await fetch('/api/quote', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('Quote response:', data);
                
                if (data.success && data.data) {
                    const quote = data.data;
                    currentQuote = data;
                    
                    const outputAmount = quote.output_formatted || quote.estimatedOutput || quote.outputAmount || '0';
                    document.getElementById('to-amount').value = parseFloat(outputAmount).toFixed(6);
                    
                    const swapInfo = document.getElementById('swap-info');
                    const priceImpact = quote.compound_impact || quote.priceImpact || '0';
                    const minOutput = quote.min_output_formatted || quote.minimumOutput || '0';
                    
                    document.getElementById('price-impact').textContent = `${(parseFloat(priceImpact) * 100).toFixed(3)}%`;
                    document.getElementById('minimum-received').textContent = `${parseFloat(minOutput).toFixed(6)} ${toToken}`;
                    document.getElementById('gas-estimate').textContent = quote.gas_estimate || quote.gasEstimate || 'Est.';
                    swapInfo.classList.remove('hidden');
                    
                    // Update exchange rate
                    const rate = parseFloat(outputAmount) / parseFloat(amount);
                    document.getElementById('exchange-rate').textContent = `1 ${fromToken} = ${rate.toFixed(6)} ${toToken}`;
                    
                    updateSwapButton();
                    showResult(`✅ Quote: ${parseFloat(outputAmount).toFixed(6)} ${toToken}`);
                    
                } else {
                    throw new Error(data.error || 'Quote failed');
                }
            } catch (error) {
                console.error('Quote error:', error);
                showResult(`❌ Quote error: ${error.message}`);
                document.getElementById('to-amount').value = '';
                document.getElementById('swap-info').classList.add('hidden');
                currentQuote = null;
                updateSwapButton();
            }
        }

        function updateSwapButton() {
            const swapButton = document.getElementById('swap-button');
            
            if (!userAccount) {
                swapButton.disabled = true;
                swapButton.textContent = 'Connect Wallet';
                return;
            }
            
            if (!currentQuote) {
                swapButton.disabled = true;
                swapButton.textContent = 'Enter Amount';
                return;
            }
            
            swapButton.disabled = false;
            swapButton.textContent = 'Execute Swap';
        }

        // ERC20 ABI for approve function
        const ERC20_ABI = [
            "function approve(address spender, uint256 amount) public returns (bool)",
            "function allowance(address owner, address spender) public view returns (uint256)",
            "function balanceOf(address account) public view returns (uint256)"
        ];

        async function checkAndApproveToken(tokenAddress, spenderAddress, amount) {
            if (tokenAddress === '0x0000000000000000000000000000000000000000') {
                return true;
            }

            try {
                const tokenContract = new ethers.Contract(tokenAddress, ERC20_ABI, signer);
                
                // Get token info to determine decimals
                const fromTokenData = allTokens.find(token => token.address.toLowerCase() === tokenAddress.toLowerCase());
                const decimals = fromTokenData ? parseInt(fromTokenData.decimals) || 18 : 18;
                
                const allowance = await tokenContract.allowance(userAccount, spenderAddress);
                const amountBN = ethers.utils.parseUnits(amount.toString(), decimals);
                
                console.log('Current allowance:', ethers.utils.formatUnits(allowance, decimals));
                console.log('Required amount:', amount);
                
                if (allowance.lt(amountBN)) {
                    showResult('🔐 Token approval required. Please approve in your wallet...');
                    
                    const maxAmount = ethers.constants.MaxUint256;
                    const approveTx = await tokenContract.approve(spenderAddress, maxAmount);
                    
                    showResult('⏳ Waiting for approval confirmation...');
                    await approveTx.wait();
                    
                    showResult('✅ Token approved successfully!');
                    return true;
                }
                
                return true;
            } catch (error) {
                console.error('Approval error:', error);
                throw new Error(`Token approval failed: ${error.message}`);
            }
        }

        async function executeSwap() {
            if (!userAccount) {
                showResult('❌ Please connect your wallet first');
                return;
            }

            if (!signer) {
                showResult('❌ Wallet not properly connected. Please reconnect your wallet.');
                console.error('Signer is null, reconnecting...');
                await connectWallet();
                return;
            }

            const fromToken = document.getElementById('from-token').value;
            const toToken = document.getElementById('to-token').value;
            const amount = document.getElementById('from-amount').value;
            const slippage = document.getElementById('slippage').value;

            if (!fromToken || !toToken || !amount) {
                showResult('❌ Please fill in all swap details');
                return;
            }

            showResult('🔄 Getting fresh quote for execution...');

            try {
                console.log('Executing swap:', { fromToken, toToken, amount, slippage });
                
                const response = await fetch('/api/quote', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        amount: amount.toString(),
                        from: fromToken,
                        to: toToken,
                        sender: userAccount,
                        slippage: parseFloat(slippage) * 100
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                console.log('Quote response for swap:', data);

                if (data.success && data.data) {
                    let txData = null;
                    
                    if (data.data.transaction) {
                        txData = data.data.transaction;
                    } else if (data.data.quote && data.data.quote.transaction) {
                        txData = data.data.quote.transaction;
                    } else if (currentQuote && currentQuote.data && currentQuote.data.transaction) {
                        txData = currentQuote.data.transaction;
                        console.log('Using transaction data from current quote');
                    }
                    
                    if (!txData) {
                        throw new Error('No transaction data available. Please get a fresh quote.');
                    }
                    
                    console.log('Transaction data:', txData);
                    
                    const fromTokenData = allTokens.find(token => token.symbol === fromToken);
                    if (!fromTokenData) {
                        throw new Error(`Token ${fromToken} not found`);
                    }
                    
                    let hasEnoughBalance = false;
                    let actualBalance;
                    
                    if (fromTokenData.address === '0x0000000000000000000000000000000000000000') {
                        // Native token (MON)
                        actualBalance = await provider.getBalance(userAccount);
                        const amountBN = ethers.utils.parseEther(amount.toString());
                        hasEnoughBalance = actualBalance.gte(amountBN);
                        console.log('Native balance:', ethers.utils.formatEther(actualBalance), 'Required:', amount);
                    } else {
                        // ERC20 token
                        const tokenContract = new ethers.Contract(fromTokenData.address, ERC20_ABI, signer);
                        actualBalance = await tokenContract.balanceOf(userAccount);
                        
                        // Use correct decimals for the token
                        const decimals = parseInt(fromTokenData.decimals) || 18;
                        const amountBN = ethers.utils.parseUnits(amount.toString(), decimals);
                        hasEnoughBalance = actualBalance.gte(amountBN);
                        
                        const balanceFormatted = ethers.utils.formatUnits(actualBalance, decimals);
                        console.log(`Token ${fromToken} balance:`, balanceFormatted, 'Required:', amount);
                        
                        // Update our local balance cache
                        userBalances[fromToken] = balanceFormatted;
                        updateBalanceDisplays();
                    }
                    
                    if (!hasEnoughBalance) {
                        const balanceDisplay = fromTokenData.address === '0x0000000000000000000000000000000000000000' ? 
                            ethers.utils.formatEther(actualBalance) :
                            ethers.utils.formatUnits(actualBalance, parseInt(fromTokenData.decimals) || 18);
                            
                        throw new Error(`Insufficient ${fromToken} balance. You have ${balanceDisplay} ${fromToken}, but need ${amount} ${fromToken}`);
                    }
                    
                    if (fromTokenData.address !== '0x0000000000000000000000000000000000000000') {
                        await checkAndApproveToken(fromTokenData.address, txData.to, amount);
                    }
                    
                    showResult('💫 Sending swap transaction to wallet...');
                    
                    const txParams = {
                        to: txData.to,
                        data: txData.data,
                        value: txData.value || '0x0'
                    };
                    
                    if (txData.gasLimit) {
                        txParams.gasLimit = txData.gasLimit;
                    } else if (txData.gas) {
                        txParams.gasLimit = txData.gas;
                    } else {
                        txParams.gasLimit = 500000;
                    }
                    
                    console.log('Sending transaction with params:', txParams);
                    
                    if (!signer) {
                        throw new Error('Signer not available. Please reconnect wallet.');
                    }
                    
                    let tx;
                    try {
                        tx = await signer.sendTransaction(txParams);
                    } catch (gasError) {
                        console.log('Failed with gas estimation, trying with higher gas limit...');
                        txParams.gasLimit = 800000;
                        tx = await signer.sendTransaction(txParams);
                    }

                    showResult(`🚀 Transaction submitted! Hash: ${tx.hash}`);
                    
                    console.log('Transaction sent:', tx);
                    
                    const receipt = await tx.wait();
                    console.log('Transaction receipt:', receipt);
                    
                    showResult(`✅ Swap completed!\n${amount} ${fromToken} → ${toToken}\nHash: ${receipt.transactionHash}`);
                    
                    document.getElementById('from-amount').value = '';
                    document.getElementById('to-amount').value = '';
                    document.getElementById('swap-info').classList.add('hidden');
                    currentQuote = null;
                    updateSwapButton();
                    
                    setTimeout(async () => {
                        await loadUserBalances();
                        showResult('💰 Balances updated!');
                    }, 3000);
                    
                } else {
                    throw new Error(data.error || 'Swap preparation failed');
                }
                
            } catch (error) {
                console.error('Swap execution error:', error);
                
                let errorMessage = error.message || 'Unknown error';
                
                if (error.code === 4001) {
                    errorMessage = 'Transaction rejected by user';
                } else if (error.code === -32603) {
                    errorMessage = 'Internal RPC error - please try again';
                } else if (error.code === -32000) {
                    errorMessage = 'Insufficient funds or gas';
                } else if (error.message && error.message.includes('insufficient funds')) {
                    errorMessage = 'Insufficient balance for this swap';
                } else if (error.message && error.message.includes('insufficient allowance')) {
                    errorMessage = 'Token approval failed. Please try again.';
                } else if (error.message && error.message.includes('Token approval failed')) {
                    errorMessage = error.message;
                } else if (error.code === 'UNPREDICTABLE_GAS_LIMIT') {
                    errorMessage = 'Gas estimation failed. Please check: 1) You have enough token balance, 2) Token is approved, 3) Network connection is stable. Try reducing the swap amount.';
                } else if (error.message && error.message.includes('execution reverted')) {
                    errorMessage = 'Transaction would fail. This usually means insufficient balance, insufficient liquidity, or price has changed significantly.';
                }
                
                showResult(`❌ Swap failed: ${errorMessage}`);
            }
        }

        // Close modal when clicking outside
        document.addEventListener('click', (e) => {
            const modal = document.getElementById('token-modal');
            const modalContent = document.querySelector('.token-modal');
            
            if (modal.classList.contains('active') && !modalContent.contains(e.target)) {
                closeTokenModal();
            }
        });

        // Close modal with Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeTokenModal();
            }
        });

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            console.log('🚀 Monorail DEX Interface loaded');
            
            // Убеждаемся что все обработчики событий работают
            setupEventListeners();
            
            try {
                checkWalletConnection();
                loadTokens();
                createAnimatedBackground();
            } catch (error) {
                console.error('Initialization error:', error);
            }
        });

        // Функция для настройки обработчиков событий
        function setupEventListeners() {
            // Обработчики для селекторов токенов
            const fromSelector = document.querySelector('.currency-selector[onclick*="from"]');
            const toSelector = document.querySelector('.currency-selector[onclick*="to"]');
            
            if (fromSelector) {
                fromSelector.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    toggleTokenSelector('from');
                });
            }
            
            if (toSelector) {
                toSelector.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    toggleTokenSelector('to');
                });
            }
            
            // Обработчик для кнопки подключения кошелька
            const connectBtn = document.getElementById('connect-wallet');
            if (connectBtn) {
                connectBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    connectWallet();
                });
            }
            
            console.log('✅ Event listeners setup complete');
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize app on page load
            window.addEventListener('load', async () => {
                console.log('Page loaded, initializing application...');
                showResult('🚀 Initializing Monad Windrose Swap...');
                
                try {
                    const tokensLoaded = await loadTokens();
                    
                    // Create animated background particles
                    createAnimatedBackground();
                    
                    // Auto-connect if wallet was previously connected
                    if (window.ethereum && window.ethereum.selectedAddress) {
                        console.log('Auto-connecting to previously connected wallet...');
                        await connectWallet();
                    } else {
                        showResult('💫 Ready to swap! Connect your wallet to get started.');
                    }
                    
                } catch (error) {
                    console.error('Initialization error:', error);
                    showResult(`❌ Initialization failed: ${error.message}`);
                }
            });

            // Listen for account changes
            if (window.ethereum) {
                window.ethereum.on('accountsChanged', async (accounts) => {
                    console.log('Accounts changed:', accounts);
                    if (accounts.length === 0) {
                        userAccount = null;
                        provider = null;
                        signer = null;
                        userBalances = {};
                        await updateWalletUI();
                        showResult('👋 Wallet disconnected');
                    } else if (accounts[0] !== userAccount) {
                        userAccount = accounts[0];
                        if (provider) {
                            signer = provider.getSigner();
                            await updateWalletUI();
                            showResult(`🔄 Switched to account: ${userAccount.slice(0, 6)}...${userAccount.slice(-4)}`);
                        }
                    }
                });

                window.ethereum.on('chainChanged', (chainId) => {
                    console.log('Chain changed:', chainId);
                    showResult('🔄 Network changed. Please refresh the page if needed.');
                    // Optionally reload the page
                    // window.location.reload();
                });
            }

            // Create animated background particles
            function createAnimatedBackground() {
                const background = document.getElementById('animationBackground');
                if (!background) return;
                
                // Clear existing particles
                background.innerHTML = '';
                
                // Create particles
                for (let i = 0; i < 50; i++) {
                    const particle = document.createElement('div');
                    particle.className = Math.random() > 0.7 ? 'particle particle-large' : 'particle';
                    
                    // Random starting position
                    particle.style.left = Math.random() * 100 + '%';
                    particle.style.animationDelay = Math.random() * 20 + 's';
                    particle.style.animationDuration = (15 + Math.random() * 10) + 's';
                    
                    background.appendChild(particle);
                }
                
                // Create connection lines
                for (let i = 0; i < 10; i++) {
                    const line = document.createElement('div');
                    line.className = 'connection-line';
                    
                    const width = 100 + Math.random() * 200;
                    const height = 1;
                    
                    line.style.width = width + 'px';
                    line.style.height = height + 'px';
                    line.style.left = Math.random() * 100 + '%';
                    line.style.top = Math.random() * 100 + '%';
                    line.style.transform = `rotate(${Math.random() * 360}deg)`;
                    line.style.animationDelay = Math.random() * 3 + 's';
                    
                    background.appendChild(line);
                }
            }
        });

        // Функция для принудительного включения кликов
        function enableClicks() {
            const clickableElements = document.querySelectorAll('.currency-selector, .main-swap-button, .connect-wallet-btn, .test-button');
            clickableElements.forEach(element => {
                element.style.pointerEvents = 'auto';
                element.style.position = 'relative';
                element.style.zIndex = '10';
            });
            console.log('✅ Clicks enabled for all buttons');
        }

        // Вызываем функцию включения кликов через небольшую задержку
        setTimeout(enableClicks, 100);
    </script>
</body>
</html>